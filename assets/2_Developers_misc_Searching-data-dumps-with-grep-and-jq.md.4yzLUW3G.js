import{_ as t,c as o,o as a,ag as r}from"./chunks/framework.BRQrZDXk.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"2_Developers/misc/Searching-data-dumps-with-grep-and-jq.md","filePath":"2_Developers/misc/Searching-data-dumps-with-grep-and-jq.md"}'),s={name:"2_Developers/misc/Searching-data-dumps-with-grep-and-jq.md"};function i(n,e,h,l,p,d){return a(),o("div",null,e[0]||(e[0]=[r('<p>A great way to examine a large amount of the openlibrary data at once is to use the monthly data dumps. But these can be a bit obscure if you&#39;ve never seen them before and aren&#39;t familiar with some standard command line tools for dealing with text files and json. This is a very brief introduction with some examples, but these tools are widely used and there are lots of resources available to learn more about them on the internet, so we&#39;ll try to stick to the basics.</p><p>For those that are familiar with command line tools, the general approach is to use <code>zgrep</code> (or similar) to select only the lines we care about in the compressed data, without actually decompressing it. We can then pipe the output to <code>cut</code> to extract the json data from the end of the line, and then use <code>jq</code> to query the data about the author held within each line in a structured fashion. We&#39;ll go over that in a bit more detail and then list some example command lines to give examples of the kind of thing you can do with the data.</p><p>Start by downloading the latest authors dump which is the smallest of the files available from <a href="https://openlibrary.org/developers/dumps" target="_blank" rel="noreferrer">https://openlibrary.org/developers/dumps</a>. The same principle will apply to the other dumps, but we&#39;ll use examples from the smallest to get started.</p><p>The author dump is currently .4Gb in size while compressed for download, which would increase to 3Gb if you uncompress it. But there&#39;s no need to do that, so just download it and keep it compressed as a txt.gz file. The file will have a name similar to <code>ol_dump_authors_latest.txt.gz</code> but for the following examples we&#39;ll rename the file to <code>a.txt.gz</code> for brevity.</p><p>We don&#39;t need to uncompress the file because each entry is on it&#39;s own line, and we can extract the lines we are interested in without decompressing first. The standard tool for this is <code>zgrep</code>, but I&#39;m going to write these examples to use a tool called <code>ripgrep</code> (usually just <code>rg</code> when using it) instead. This is partly because it&#39;s a slightly simpler and faster approach for those using Windows and Mac OS X who probably need more help with this, and partly because it&#39;s what I use for these kind of tasks anyway. You&#39;ll need to Install that and <code>jq</code>, windows users may need to install a few other things as well as we go.</p><p>The basic command for seaching is <code>rg -z &#39;Maurice Sendak&#39; a.txt.gz</code>, which tells <code>rg</code> to search through a compressed file for a quoted phrase in the named file. Every line of the a.txt.gz file that matches will be output to the terminal.</p><p>There&#39;s currently 8487789 lines in the file, and it&#39;ll probably continue to grow, so a search even for a relatively unusual single name like Kardashian, Cumberbatch or Humperdinck is going to return quite a few matches, so you may want to use full names and the <code>-m5</code> option to limit the number of returns to the first 5 it finds to start with.</p><p>If you search for any of the required items that appear on every line (key, type, author, revision and so on) the entire 3GB file will be outputted. Try <code>-c</code> to just get a count of how many lines match.</p><p><code>rg -z -c type a.txt.gz</code></p><p>This takes about 5 seconds to complete on my laptop. The amount of data that comes back from most useful queries is overwhelming so we&#39;ll want to limit it further. You&#39;ll have noticed if you ran the <code>Maurice Sendak</code> search above, that it returned every line with that name on it. This includes his OpenLibrary author ID (OL366346A) and some data about his wikipedia page etc. but it also returned lines from people who mention being influenced by him in their bio and author&#39;s that collaborated with him. The first search is to cut things down to a reasonably size but then we want to be more specific with the shortlist of possible entries returned.</p><p><code>rg -z &#39;Maurice Sendak&#39; a.txt.gz | cut -f5 | jq .name</code></p><p>Should extract the 5th item on each line, which is the data in a json format, then jq will print only the name from each entry.</p><p>That&#39;s the basics, there&#39;s a whole world of things you can do with these tools (e.g. jq will let you turn the json into .CSV files if that&#39;s necessary for any of your usual workflows) here&#39;s an Open Access introduction to the tool, aimed at Historians, that covers it in detail: <a href="https://programminghistorian.org/en/lessons/json-and-jq#output-a-csv-csv" target="_blank" rel="noreferrer">https://programminghistorian.org/en/lessons/json-and-jq#output-a-csv-csv</a></p><p>In particular the jqplay tool they talk about, seems very powerful for learning how it works. Pasting a few lines worth of openlibrary data into there should make it a lot faster to get up to speed than just trying things on the command line with a giant file. And you can share snippets:</p><p><a href="https://jqplay.org/s/NIq_Aku18p" target="_blank" rel="noreferrer">https://jqplay.org/s/NIq_Aku18p</a></p><p>I&#39;m hoping people will expand this page with worked examples for tasks they find useful for their own open library related tasks, and I&#39;ll try to cover some more topics in future like:</p><p><a href="https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md#common-options" target="_blank" rel="noreferrer">https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md#common-options</a></p><p>case insensitive searches: <code>rg -z -i &#39;irvine welsh&#39; a.txt.gz</code></p><p>Useful regular expressions for matching things that can vary slightly in spelling, and using <code>-o</code> to only output the bits that match</p><p>only outputting the lines that don&#39;t match <code>-v</code></p><p>Using <code>-w</code> to only match &quot;word boundaries&quot;</p><p>Searching for weird typographical characters using <code>-F</code></p><p><a href="https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md#common-options" target="_blank" rel="noreferrer">https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md#common-options</a></p><p>Sorting, counting and doing set operations on the output (e.g. how many people have wikidata IDs but no viaf id)</p><p>Advanced use of jq query language.</p>',25)]))}const m=t(s,[["render",i]]);export{u as __pageData,m as default};
