import{_ as a,c as n,o as t,ag as o}from"./chunks/framework.BRQrZDXk.js";const u=JSON.parse('{"title":"What is a component?","description":"","frontmatter":{},"headers":[],"relativePath":"6_Advanced/Component-Library.md","filePath":"6_Advanced/Component-Library.md"}'),s={name:"6_Advanced/Component-Library.md"};function i(r,e,c,p,l,h){return t(),n("div",null,e[0]||(e[0]=[o(`<p>OpenLibrary does not have one of these yet, but we strive to do so, evolving the foundations laid in the <a href="/openlibrary-docs/3_Designers/Design-Pattern-Library.html">Design-Pattern-Library</a></p><h1 id="what-is-a-component" tabindex="-1">What is a component? <a class="header-anchor" href="#what-is-a-component" aria-label="Permalink to &quot;What is a component?&quot;">​</a></h1><p>A component is a language agnostic block of HTML styled by CSS, which may or may not use JavaScript to enhance it. Some components will be rendered in Python on the server side, some will be rendered on JavaScript and some will be rendered in both.</p><p>A component should be reusable. It should not make sure of id&#39;s in any way and if it does, these should be provided as parameters to the user of the component.</p><h1 id="specification-for-a-component" tabindex="-1">Specification for a component <a class="header-anchor" href="#specification-for-a-component" aria-label="Permalink to &quot;Specification for a component&quot;">​</a></h1><ul><li>A component will use some kind of templating library to render a block of HTML. A base CSS</li><li>It may use JavaScript to append additional HTML elements and wire up behaviours.</li><li>A component is a JavaScript class or a Python function that returns an HTML string OR an HTML element.</li></ul><h1 id="rules-for-a-component" tabindex="-1">Rules for a component <a class="header-anchor" href="#rules-for-a-component" aria-label="Permalink to &quot;Rules for a component&quot;">​</a></h1><h2 id="server-side-rendered-components" tabindex="-1">Server side rendered components <a class="header-anchor" href="#server-side-rendered-components" aria-label="Permalink to &quot;Server side rendered components&quot;">​</a></h2><h3 id="a-component-must-be-usable-when-javascript-is-disabled" tabindex="-1">A component must be usable when JavaScript is disabled. <a class="header-anchor" href="#a-component-must-be-usable-when-javascript-is-disabled" aria-label="Permalink to &quot;A component must be usable when JavaScript is disabled.&quot;">​</a></h3><p>JavaScript progressively enhances such components to add functionality (for example changing a link to open a dialog instead).</p><h3 id="when-a-component-is-progressively-enhanced-it-must-not-cause-reflow-or-repaint" tabindex="-1">When a component is progressively enhanced it must not cause <a href="https://javascript.tutorialhorizon.com/2015/06/06/what-are-reflows-and-repaints-and-how-to-avoid-them/" target="_blank" rel="noreferrer">reflow or repaint</a> <a class="header-anchor" href="#when-a-component-is-progressively-enhanced-it-must-not-cause-reflow-or-repaint" aria-label="Permalink to &quot;When a component is progressively enhanced it  must not cause [reflow or repaint](https://javascript.tutorialhorizon.com/2015/06/06/what-are-reflows-and-repaints-and-how-to-avoid-them/)&quot;">​</a></h3><p>This is important as it keeps the experience smooth.</p><h3 id="no-duplication" tabindex="-1">No duplication. <a class="header-anchor" href="#no-duplication" aria-label="Permalink to &quot;No duplication.&quot;">​</a></h3><p>A component should have a single source of truth.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>class UI:</span></span>
<span class="line"><span>  def goodform( btnLabel ):</span></span>
<span class="line"><span>     return &#39;&lt;div class=&quot;form&quot;&gt;%s&lt;/div&gt;&#39;%self::btn(btnLabel)</span></span>
<span class="line"><span>  def badform( btnLabel ):</span></span>
<span class="line"><span>     return &#39;&lt;div class=&quot;form&quot;&gt;&lt;button class=&quot;btn&quot;&gt;%s&lt;/button&gt;&lt;/div&gt;&#39;%btnLabel</span></span>
<span class="line"><span>  def btn( label ):</span></span>
<span class="line"><span>     return &#39;&lt;button class=&quot;btn&quot;&gt;%s&lt;/button&gt;&#39;%label</span></span></code></pre></div><h2 id="js-components" tabindex="-1">JS components <a class="header-anchor" href="#js-components" aria-label="Permalink to &quot;JS components&quot;">​</a></h2><h3 id="components-must-be-scoped-and-cannot-have-side-effects-on-things-outside-their-scope" tabindex="-1">Components must be scoped and cannot have side effects on things outside their scope. <a class="header-anchor" href="#components-must-be-scoped-and-cannot-have-side-effects-on-things-outside-their-scope" aria-label="Permalink to &quot;Components must be scoped and cannot have side effects on things outside their scope.&quot;">​</a></h3><p>When considering the DOM tree, a component should not be able to access any parent elements. Likewise another component cannot make modifications to it. This means a component cannot bind events to document.body for example. This is important as it avoids unexpected conflicting behaviours, for example consider the following example where a list widget registers an event to close itself, but a SearchBar stops propagation preventing that event from ever occurring:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function SearchBar() { $( &#39;body&#39; ).on( &#39;click&#39;, (ev) =&gt; ev.stopPropagation() ); }</span></span>
<span class="line"><span>function ListWidget() { $( &#39;html&#39; ).on( &#39;click&#39;, (ev) =&gt; { this.closeListWidget(); } ); }</span></span>
<span class="line"><span>new SearchBar();</span></span>
<span class="line"><span>new ListWidget();</span></span></code></pre></div><h3 id="components-manage-their-own-state" tabindex="-1">Components manage their own state <a class="header-anchor" href="#components-manage-their-own-state" aria-label="Permalink to &quot;Components manage their own state&quot;">​</a></h3><p>We will probably want to use something like Redux to manage application state, but while we refactor and in the absence of such as library we should at least ensure that components keep their own state. This means that other components should not be changing.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function SearchBar() { this.state = { foo: 1 }; }</span></span>
<span class="line"><span>const sb = new SearchBar();</span></span>
<span class="line"><span>// bad!</span></span>
<span class="line"><span>function Bar() { sb.state.foo = 2 }</span></span></code></pre></div><h3 id="components-are-event-driven" tabindex="-1">Components are event-driven <a class="header-anchor" href="#components-are-event-driven" aria-label="Permalink to &quot;Components are event-driven&quot;">​</a></h3><p>I would like us to take an event driven approach to building out components in OpenLibrary.</p><p>The components should not make assumptions such as &quot;clicking X saves something to localStorage&quot;. This will be left to the consumer.</p><p>This ensures that our components are as reusable as possible and that we can document them with minimum dependencies in storybook ui.</p><p>It also means the widget can be used in other contexts. For example we might want to add a search bar in a lists widget feature as well as the main header.</p><p>We may want to consider the <a href="https://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="noreferrer">observer pattern</a> as part of this.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>function SearchBar( node ) {</span></span>
<span class="line"><span>  node.querySelectorAll( &#39;.buttons&#39; ).addEventListener( &#39;click&#39;, onButtonClick );</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>new SearchBar( { onButtonClick: function () { alert(&#39;I clicked a button!&#39; ); } )</span></span></code></pre></div><h3 id="composition-not-inheritance" tabindex="-1">Composition not inheritance <a class="header-anchor" href="#composition-not-inheritance" aria-label="Permalink to &quot;Composition not inheritance&quot;">​</a></h3><p>React.js and similar libraries have shown that the composition pattern is much better for UIs than the inheritance model.</p><p><a href="https://reactjs.org/docs/composition-vs-inheritance.html" target="_blank" rel="noreferrer">https://reactjs.org/docs/composition-vs-inheritance.html</a></p><h3 id="no-inheritance" tabindex="-1">No inheritance <a class="header-anchor" href="#no-inheritance" aria-label="Permalink to &quot;No inheritance&quot;">​</a></h3><p>We should not make use of class <code>extends</code> with the exception of a framework base class.</p><p>For instance if we are using React, it is acceptable for <code>class Element extends React.Component</code> but we should not be extending anything else e.g. <code>Poodle extends Dog</code>.</p><p><a href="https://codeburst.io/inheritance-is-evil-stop-using-it-6c4f1caf5117" target="_blank" rel="noreferrer">https://codeburst.io/inheritance-is-evil-stop-using-it-6c4f1caf5117</a></p><h1 id="refactoring-existing-components" tabindex="-1">Refactoring existing components <a class="header-anchor" href="#refactoring-existing-components" aria-label="Permalink to &quot;Refactoring existing components&quot;">​</a></h1><h2 id="write-unit-tests" tabindex="-1">Write unit tests <a class="header-anchor" href="#write-unit-tests" aria-label="Permalink to &quot;Write unit tests&quot;">​</a></h2><p>We should look to write unit tests first and for all with the existing code before doing this. To support testing we should do the minimum possible e.g. exposing functions where necessary and adding return values when we need to check the return value of something.</p><p>The existence of tests should be a precursor to any large refactor as it defines a specification of how a feature behaves and makes it easier for others in the team to verify that the new component is an adequate replacement.</p><h2 id="refactor" tabindex="-1">Refactor. <a class="header-anchor" href="#refactor" aria-label="Permalink to &quot;Refactor.&quot;">​</a></h2>`,41)]))}const m=a(s,[["render",i]]);export{u as __pageData,m as default};
